<?php

namespace MSL;

//========================================================================================
//                                                                                        
//  ####     #####         ##     ##   #####   ######        #####  ####    ##  ######  
//  ##  ##  ##   ##        ####   ##  ##   ##    ##          ##     ##  ##  ##    ##    
//  ##  ##  ##   ##        ##  ## ##  ##   ##    ##          #####  ##  ##  ##    ##    
//  ##  ##  ##   ##        ##    ###  ##   ##    ##          ##     ##  ##  ##    ##    
//  ####     #####         ##     ##   #####     ##          #####  ####    ##    ##    
//                                                                                        
//========================================================================================

/******************************************************************
 *                          VERSION: 1.1                          *
 *                   UPDATED: 2022-02-15  BY MM                   *
 *                       BUILD: 2022-02-13                        *
 *                     DO NOT EDIT THIS FILE                      *
 * THIS FILE CONTAIN CORE FUNCTIONALITY OF ADVANCE CACHING SYSTEM *
 *                         AVOID EDITING                          *
 *                             BY MM                              *
 ******************************************************************/

use Closure;
use Illuminate\Support\Facades\File;

class ViewCache
{
    private static $html = null;
    private static $cache = null;

    public function __construct()
    {
        self::$cache = storage_path('framework' . DIRECTORY_SEPARATOR . 'cache' . DIRECTORY_SEPARATOR . 'micro-views');
    }
    private static function init($html)
    {
        self::$html = $html;
    }
    public static function cacheView(Closure $fullHTMLFunction, $key, $ttl, $tags = ["pages"])
    {
        if ($ttl == 0 && sizeof($tags) > 0) {
            return $fullHTMLFunction();
        }
        $now = time();
        $ttl = ($now + $ttl);
        if (sizeof($tags) > 0) {
            $cache_path = self::createFolderStructure($tags, $key);
            if (file_exists($cache_path)) {
                $verifyCache = self::technicallyGettingCacheData($cache_path, $now);
                if (!$verifyCache === '--mm-no-cache-found--') {
                    //create html minify instance
                    $fullHTML = $fullHTMLFunction();
                    self::init($fullHTML);
                    $html = self::minifyHTML();
                    //
                    return self::saveCache($cache_path, $html, $ttl, $now);
                }
                return $verifyCache;
            } else {
                //create html minify instance
                $fullHTML = $fullHTMLFunction();
                self::init($fullHTML);
                $html = self::minifyHTML();
                //
                return self::saveCache($cache_path, $html, $ttl, $now);
            }
        } else {
            return $fullHTMLFunction();
        }
    }
    public static function flush_cache($tags = [], $key = false)
    {
        if ($key) {
            return self::removeCache(self::createFolderStructure($tags, $key));
        } else {
            return self::removeCache(self::createFolderStructureOnly($tags), true);
        }
    }

    public static function flush_all()
    {
        File::deleteDirectory(self::createFolderStructureOnly([]));
        return true;
    }
    private static function minifyHTML()
    {
        $html = self::sanitizeOutput(self::$html);
        return $html;
    }
    private static function saveCache($path, $data, $ttl, $now)
    {
        $store = $ttl . "mm:" . $data;
        File::put($path, $store);
        $return = self::technicallyGettingCacheData($path, $now);
        if (!$return) {
            return $data;
        }
        return $return;
    }
    private static function createFolderStructure($tags, $key)
    {
        $path = self::createFolderStructureOnly($tags);
        return self::releaseFolder($path) . DIRECTORY_SEPARATOR . md5($key) . "-MM.html";
    }
    private static function createFolderStructureOnly($tags)
    {
        $path = self::$cache;
        $folder = '';
        foreach ($tags as $tag) {
            $folder .= DIRECTORY_SEPARATOR . $tag;
        }

        return $path . $folder;
    }
    private static function releaseFolder($path)
    {
        if (file_exists($path)) {
            return $path;
        } else {
            mkdir($path, 0755, true);
            return $path;
        }
    }
    private static function removeCache($path, $directory = false)
    {
        if ($directory) {
            File::deleteDirectory($path);
        } else {
            File::delete($path);
        }
        return true;
    }
    private static function sanitizeOutput($buffer)
    {
        $search = array(
            '/\>[^\S ]+/s',     // strip whitespaces after tags, except space
            '/[^\S ]+\</s',     // strip whitespaces before tags, except space
            '/(\s)+/s',         // shorten multiple whitespace sequences
            '/<!--(.|\s)*?-->/' // Remove HTML comments
        );
        $replace = array(
            '>',
            '<',
            '\\1',
            ''
        );
        $buffer = preg_replace($search, $replace, $buffer);
        return $buffer;
    }
    private static function technicallyGettingCacheData($cache_path, $now)
    {
        $get = File::get($cache_path);
        $technical_data = self::cacheTechnical($get);
        $ttl = $technical_data['ttl'];
        $data = $technical_data['data'];
        if ($ttl > $now) {
            return $data;
        } else {
            // return false;
            return '--mm-no-cache-found--';
        }
    }
    private static function cacheTechnical($data)
    {
        preg_match("/([0-9]+)(mm:)/", $data, $extraction);
        $get_ttl = !empty($extraction[1]) ? $extraction[1] : 0;
        $encoded_data = preg_replace("/([0-9]+)(mm:)/", '', $data, 1);
        return ["ttl" => $get_ttl, "data" => $encoded_data];
    }
}
